/**
 * @brief       : this
 * @file        : radio.c
 * @version     : v0.0.1
 * @author      : gang.cheng
 * @date        : 2016-01-14
 * change logs  :
 * Date       Version     Author        Note
 * 2016-01-14  v0.0.1  gang.cheng    first version
 */
#include "common/lib/lib.h"
#include "sys_arch/osel_arch.h"

#include "../radio_defs.h"

#include "radio.h"

#define RSSI_OFFSET_LF                              -164
#define RSSI_OFFSET_HF                              -157

/*!
 * Radio registers definition
 */
typedef struct
{
    radio_modem_t modem;
    uint8_t       addr;
    uint8_t       value;
} radio_regs_t;

/*!
 * \brief Radio hardware registers initialization definition
 *
 * \remark Can be automatically generated by the SX1272 GUI (not yet implemented)
 */
#define RADIO_INIT_REGISTERS_VALUE                \
{                                                 \
    { MODEM_FSK , REG_LNA                , 0x23 },\
    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\
    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\
    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\
    { MODEM_FSK , REG_OSC                , 0x07 },\
    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\
    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\
    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\
    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\
    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\
    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\
    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\
    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\
    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\
    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\
}

const radio_regs_t radio_regs_init[] = RADIO_INIT_REGISTERS_VALUE;

radio_settings_t sx127x;


void sx127x_write_buffer(uint8_t addr, uint8_t *buf, uint8_t size)
{
    SX127X_SPI_BEGIN();

    sx127x_spi_write_read(addr & FIFO_READ_MASK);

    for (uint8_t i = 0; i < size; i++)
    {
        sx127x_spi_write_read(buf[i]);
    }

    SX127X_SPI_END();
}

void sx127x_read_buffer(uint8_t addr, uint8_t *buf, uint8_t size)
{
    SX127X_SPI_BEGIN();

    sx127x_spi_write_read(addr & FIFO_READ_MASK);

    for (uint8_t i = 0; i < size; i++)
    {
        buf[i] = sx127x_spi_write_read(0xFF);
    }

    SX127X_SPI_END();
}

void sx127x_write_reg(uint8_t addr, uint8_t data)
{
    sx127x_write_buffer(addr, &data, 1);
}

uint8_t sx127x_read_reg(uint8_t addr)
{
    uint8_t data;
    sx127x_read_buffer(addr, data, 1);

    return data;
}

static void sx127x_set_channel(uint32_t freq)
{
    sx127x.freq = freq;
    freq = (uint32_t)((fp32_t)freq / (fp32_t)FREQ_STEP);

    sx127x_write_reg( REG_FRFMSB, ( uint8_t )( ( freq >> 16 ) & 0xFF ) );
    sx127x_write_reg( REG_FRFMID, ( uint8_t )( ( freq >> 8 ) & 0xFF ) );
    sx127x_write_reg( REG_FRFLSB, ( uint8_t )( freq & 0xFF ) );
}

static uint8_t sx127x_get_pa_select(uint32_t freq)
{
    if ( freq > RF_MID_BAND_THRESH )
    {
        return RF_PACONFIG_PASELECT_PABOOST;
    }
    else
    {
        return RF_PACONFIG_PASELECT_RFO;
    }
}

static void sx127x_set_ant_sw_lowpower(bool_t status)
{
    static radio_is_active = FALSE;
    if (radio_is_active != status)
    {
        radio_is_active = status;

        if (status == FALSE)
        {
            sx127x_ant_sw_init();
        }
        else
        {
            sx_127x_ant_sw_deinit();
        }
    }
}


void sx127x_set_op_mode(uint8_t op_mode)
{
    static uint8_t op_mode_prev = RF_OPMODE_STANDBY;

    if (op_mode != op_mode_prev)
    {
        op_mode_prev = op_mode;
        if (op_mode == RF_OPMODE_SLEEP)
        {
            sx127x_set_ant_sw_lowpower(TRUE);
        }
        else
        {
            sx127x_set_ant_sw_lowpower(FALSE);
            if (op_mode == RF_OPMODE_TRANSMITTER)
            {
                sx127x_ant_sw_set(1);
            }
            else
            {
                sx127x_ant_sw_set(0);
            }
        }

        sx127x_write_reg( REG_OPMODE,
                          ( sx127x_read_reg( REG_OPMODE ) & RF_OPMODE_MASK ) | op_mode );
    }
}

static void sx127x_set_modem(radio_modem_t modem)
{
    if (sx127x.modem == modem)
    {
        return;
    }

    sx127x.modem = modem;
    sx127x_set_op_mode(RF_OPMODE_SLEEP);
    sx127x.state = RF_SLEEP_STATE;
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        sx127x_write_reg( REG_OPMODE, ((sx127x_read_reg( REG_OPMODE ) &
                                        RFLR_OPMODE_LONGRANGEMODE_MASK ) |
                                       RFLR_OPMODE_LONGRANGEMODE_OFF) );

        sx127x_write_reg( REG_DIOMAPPING1, 0x00 );
        sx127x_write_reg( REG_DIOMAPPING2, 0x30 ); // DIO5=ModeReady
        break;

    case MODEM_LORA:
        sx127x_write_reg( REG_OPMODE, (( sx127x_read_reg( REG_OPMODE ) &
                                         RFLR_OPMODE_LONGRANGEMODE_MASK ) |
                                       RFLR_OPMODE_LONGRANGEMODE_ON ));

        sx127x_write_reg( REG_DIOMAPPING1, 0x00 );
        sx127x_write_reg( REG_DIOMAPPING2, 0x00 );
        break;
    }
}


static void sx127x_set_power(uint8_t power)
{
    pa_config = sx127x_read_reg( REG_PACONFIG );
    paDac = sx127x_read_reg( REG_PADAC );

    pa_config = ( pa_config & RF_PACONFIG_PASELECT_MASK ) |
                sx127x_get_pa_select( sx127x.freq );
    pa_config = ( pa_config & RF_PACONFIG_MAX_POWER_MASK ) | 0x70;

    if ( ( pa_config & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
    {
        if ( power > 17 )
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
        }
        if ( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
        {
            if ( power < 5 )
            {
                power = 5;
            }
            if ( power > 20 )
            {
                power = 20;
            }
            pa_config = (pa_config & RF_PACONFIG_OUTPUTPOWER_MASK) |
                        (uint8_t)((uint16_t)(power - 5) & 0x0F );
        }
        else
        {
            if ( power < 2 )
            {
                power = 2;
            }
            if ( power > 17 )
            {
                power = 17;
            }
            pa_config = (pa_config & RF_PACONFIG_OUTPUTPOWER_MASK) |
                        (uint8_t)((uint16_t)(power - 2) & 0x0F );
        }
    }
    else
    {
        if ( power < -1 )
        {
            power = -1;
        }
        if ( power > 14 )
        {
            power = 14;
        }
        pa_config = ( pa_config & RF_PACONFIG_OUTPUTPOWER_MASK )
                    | ( uint8_t )( ( uint16_t )( power + 1 ) & 0x0F );
    }
    sx127x_write_reg( REG_PACONFIG, pa_config );
    sx127x_write_reg( REG_PADAC, paDac );
}

static void sx127x_set_freq_offset(uint32_t value)
{
    //@todo fsk only
}

/**
 * [sx127x_set_preamble description]
 * \param [IN] preambleLen  Sets the preamble length
 *      FSK : Number of bytes
 *      LoRa: Length in symbols (the hardware adds 4 more symbols)
 */
static void sx127x_set_preamble(uint8_t preambleLen)
{
    sx127x.lora.preamble_len = preambleLen;
    if (sx127x.modem == MODEM_FSK)
    {
        sx127x_write_reg( REG_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
        sx127x_write_reg( REG_PREAMBLELSB, preambleLen & 0xFF );
    }
    else
    {
        sx127x_write_reg( REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
        sx127x_write_reg( REG_LR_PREAMBLELSB, preambleLen & 0xFF );
    }
}

/**
 * [sx127x_set_rxtimeout description]
 * @param value timeout = value * Ts
 */
static void sx127x_set_rxtimeout(uint16_t value)
{
    sx127x_write_reg( REG_LR_MODEMCONFIG2,
                      ( sx127x_read_reg( REG_LR_MODEMCONFIG2 ) &
                        RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
                      ((value >> 8) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK));

    sx127x_write_reg( REG_LR_SYMBTIMEOUTLSB, (uint8_t)(symbTimeout & 0xFF));
}

/**
 * [sx127x_set_fix description]
 * @param fix_en      [Fixed length packets [0: variable, 1: fixed]]
 * @param payload_len
 */
void sx127x_set_fix(uint8_t fix_len, uint8_t payload_len)
{
    sx127x.lora.fix_len  = fix_len;
    sx127x_write_reg( REG_LR_MODEMCONFIG1,
                      ( sx127x_read_reg( REG_LR_MODEMCONFIG1 ) &
                        RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) | fix_len );

    if (fix_len == 1)
    {
        sx127x_write_reg( REG_LR_PAYLOADLENGTH, payload_len );
    }
}

void sx127x_set_iqinverted(bool_t iq_inverted)
{
    sx127x.lora.iq_inverted = iq_inverted;
    if (sx127x.lora.iq_inverted == TRUE)
    {
        sx127x_write_reg(REG_LR_INVERTIQ, ((sx127x_read_reg(REG_LR_INVERTIQ) &
                                            RFLR_INVERTIQ_TX_MASK &
                                            RFLR_INVERTIQ_RX_MASK ) |
                                           RFLR_INVERTIQ_RX_OFF |
                                           RFLR_INVERTIQ_TX_ON));
        sx127x_write_reg(REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);
    }
    else
    {
        sx127x_write_reg(REG_LR_INVERTIQ, ((sx127x_read_reg(REG_LR_INVERTIQ) &
                                            RFLR_INVERTIQ_TX_MASK &
                                            RFLR_INVERTIQ_RX_MASK ) |
                                           RFLR_INVERTIQ_RX_OFF |
                                           RFLR_INVERTIQ_TX_OFF));
        sx127x_write_reg(REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);
    }
}

/**
 * [sx127x_set_bandwidth description]
 * @param [in] bandwidth
 *  - 0 7.8k
 *  - 1 10.4k
 *  - 2 15.6k
 *  - 3 20.8k
 *  - 4 31.25k
 *  - 5 41.7k
 *  - 6 62.5k
 *  - 7 125k
 *  - 8 250k
 *  - 9 500k
 *  @param [in] datarate  Sets the Datarate
 *      FSK : 600..300000 bits/s
 *      LoRa: [6: 64, 7: 128, 8: 256, 9: 512,
 *             10: 1024, 11: 2048, 12: 4096  chips]
 *  @param [in] coderate Sets the coding rate (LoRa only)
 *      FSK : N/A ( set to 0 )
 *      LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]
 *  @param [in] crcOn        Enables disables the CRC [0: OFF, 1: ON]
 */
static void sx127x_set_config(uint8_t bandwidth,
                              uint32_t datarate,
                              uint8_t coderate,
                              uint8_t crc_on)
{
    if (sx127x.modem == MODEM_FSK)
    {
        //@todo
        return;
    }
    else
    {
        sx127x.lora.bandwidth = bandwidth;
        sx127x.lora.datarate  = datarate;
        sx127x.lora.coderate  = coderate;

        if ( datarate > 12 )
        {
            datarate = 12;
        }
        else if ( datarate < 6 )
        {
            datarate = 6;
        }
        if ( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
                ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
        {
            sx127x.lora.low_datarate_optimize = TRUE;
        }
        else
        {
            sx127x.lora.low_datarate_optimize = FALSE;
        }

        sx127x_write_reg( REG_LR_MODEMCONFIG1,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG1 ) &
                            RFLR_MODEMCONFIG1_BW_MASK &
                            RFLR_MODEMCONFIG1_CODINGRATE_MASK) |
                          ( bandwidth << 4 ) | ( coderate << 1 ) );

        sx127x_write_reg( REG_LR_MODEMCONFIG2,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG2 ) &
                            RFLR_MODEMCONFIG2_SF_MASK &
                            RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
                          ( datarate << 4 ) | ( crc_on << 2 ) );

        sx127x_write_reg( REG_LR_MODEMCONFIG3,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG3 ) &
                            RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                          ( sx127x.lora.low_datarate_optimize << 3 ) );

        if ( ( bandwidth == 9 ) && ( RF_MID_BAND_THRESH ) )
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x02 );
            sx127x_write_reg( REG_LR_TEST3A, 0x64 );
        }
        else if ( bandwidth == 9 )
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x02 );
            sx127x_write_reg( REG_LR_TEST3A, 0x7F );
        }
        else
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x03 );
        }

        if ( datarate == 6 )
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                                RFLR_DETECTIONOPTIMIZE_MASK ) |
                              RFLR_DETECTIONOPTIMIZE_SF6 );
            sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                              RFLR_DETECTIONTHRESH_SF6 );
        }
        else
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                                RFLR_DETECTIONOPTIMIZE_MASK ) |
                              RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
            sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                              RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
        }
    }
}

static void sx127x_set_hopping(bool_t freq_hop_on,
                               uint8_t hop_period)
{

    if (sx127x.modem == MODEM_FSK)
    {
        DBG_ASSERT(FALSE __DBG_LINE);
    }

    sx127x.lora.freq_hop_on = freq_hop_on;
    sx127x.lora.hop_period  = hop_period;

    if (freq_hop_on == true )
    {
        sx127x_write_reg( REG_LR_PLLHOP,  ((sx127x_read_reg( REG_LR_PLLHOP ) &
                                            RFLR_PLLHOP_FASTHOP_MASK ) |
                                           RFLR_PLLHOP_FASTHOP_ON));
        sx127x_write_reg( REG_LR_HOPPERIOD, hop_period);
    }
}

static void rx_chain_calibration(void)
{
    uint8_t reg_paconfig_initval = sx127x_read_reg(REG_PACONFIG);
    //*< 默认获取是434Mhz
    sx127x.freq = (double)(((uint32_t)sx127x_read_reg(REG_FRFMSB) << 16) |
                           ((uint32_t)sx127x_read_reg(REG_FRFMID) << 8) |
                           ((uint32_t)sx127x_read_reg(REG_FRFLSB)))
                  * ( double )FREQ_STEP;

    // Cut the PA just in case, RFO output, power = -1 dBm
    sx127x_write_reg( REG_PACONFIG, 0x00 );

    sx127x_write_reg( REG_IMAGECAL, (( sx127x_read_reg( REG_IMAGECAL )
                                       & RF_IMAGECAL_IMAGECAL_MASK ) |
                                     RF_IMAGECAL_IMAGECAL_START ));
    while ( ( sx127x_read_reg( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING )
            == RF_IMAGECAL_IMAGECAL_RUNNING )
    {
    }

// set a frequency in HF band
    sx127x_set_channel(868000000);

// Launch Rx chain calibration for HF band
    sx127x_write_reg( REG_IMAGECAL, (( sx127x_read_reg( REG_IMAGECAL )
                                       & RF_IMAGECAL_IMAGECAL_MASK ) |
                                     RF_IMAGECAL_IMAGECAL_START ));
    while ( ( sx127x_read_reg( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING )
            == RF_IMAGECAL_IMAGECAL_RUNNING )
    {
    }

// restore context
    sx127x_write_reg(REG_PACONFIG, reg_paconfig_initval);
    sx127x_set_channel(init_freq);
}

int8_t sx127x_get_rssi(void)
{
    int8_t rssi_val = 0;
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //sx127x.fsk_packet.rssi_value = -( sx127x_read_reg( REG_RSSIVALUE ) >> 1 );
        //rssi_val = sx127x.fsk_packet.rssi_value;
        break;

    case MODEM_LORA:
    {
        int8_t snr = 0;
        sx127x.lora_packet.snr_value = sx127x_read_reg( REG_LR_PKTSNRVALUE );
        if ( sx127x.lora_packet.snr_value & 0x80 ) // The SNR sign bit is 1
        {
            // Invert and divide by 4
            snr = ( ( ~sx127x.lora_packet.snr_value + 1 ) & 0xFF ) >> 2;
            snr = -snr;
        }
        else
        {
            // Divide by 4
            snr = ( sx127x.lora_packet.snr_value & 0xFF ) >> 2;
        }

        int16_t rssi = sx127x_read_reg( REG_LR_PKTRSSIVALUE );
        if ( snr < 0 )
        {
            if ( sx127x.freq > RF_MID_BAND_THRESH )
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) +
                                                snr;
            }
            else
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) +
                                                snr;
            }
        }
        else
        {
            if ( sx127x.freq > RF_MID_BAND_THRESH )
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_HF + rssi + ( rssi >> 4 );
            }
            else
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_LF + rssi + ( rssi >> 4 );
            }
        }

        rssi_val = sx127x.lora_packet.rssi_value;
    }
    break;

    default:
        break;
    }

    return rssi_val;
}

bool_t sx127x_enter_sleep(void)
{
    if (sx127x.state == RF_SLEEP_STATE)
    {
        return FALSE;
    }

    sx127x.state = RF_SLEEP_STATE;

    sx127x_set_op_mode( RF_OPMODE_SLEEP );
}

bool_t sx127x_enter_idle(void)
{
    if (sx127x.state == RF_IDLE_STATE)
    {
        return FALSE;
    }

    sx127x.state = RF_IDLE_STATE;
    sx127x_set_op_mode(RF_OPMODE_STANDBY);
}

bool_t sx127x_enter_tx(void)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        break;

    case MODEM_LORA:
    {
        if ( sx127x.lora.freq_hop_on == TRUE )
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                              RFLR_IRQFLAGS_RXDONE |
                              RFLR_IRQFLAGS_PAYLOADCRCERROR |
                              RFLR_IRQFLAGS_VALIDHEADER |
                              RFLR_IRQFLAGS_CADDONE |
                              RFLR_IRQFLAGS_CADDETECTED );

            // DIO0=TxDone, DIO2=FhssChangeChannel
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK &
                                               RFLR_DIOMAPPING1_DIO2_MASK ) |
                             RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00);
        }
        else
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                              RFLR_IRQFLAGS_RXDONE |
                              RFLR_IRQFLAGS_PAYLOADCRCERROR |
                              RFLR_IRQFLAGS_VALIDHEADER |
                              //RFLR_IRQFLAGS_TXDONE |
                              RFLR_IRQFLAGS_CADDONE |
                              RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                              RFLR_IRQFLAGS_CADDETECTED );

            // DIO0=TxDone
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK ) |
                             RFLR_DIOMAPPING1_DIO0_01 );
        }
    }
    break;

    default:
        DBG_ASSERT(FALSE __DBG_LINE);
        break;
    }

    sx127x.state = RF_TX_STATE;
    sx127x_set_op_mode(RF_OPMODE_TRANSMITTER);
}

bool_t sx127x_enter_rx(void)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        break;

    case MODEM_LORA:
    {
        sx127x_set_iqinverted(sx127x.lora.iq_inverted);

        if (sx127x.lora.bandwidth < 9)
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) & 0x7F );
            sx127x_write_reg( REG_LR_TEST30, 0x00 );
            switch (sx127x.lora.bandwidth)
            {
            case 0: // 7.8 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x48 );
                sx127x_set_channel(sx127x.freq + 7.81e3 );
                break;
            case 1: // 10.4 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel(sx127x.freq + 10.42e3 );
                break;
            case 2: // 15.6 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel(sx127x.freq + 15.62e3 );
                break;
            case 3: // 20.8 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel(sx127x.freq + 20.83e3 );
                break;
            case 4: // 31.2 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel(sx127x.freq + 31.25e3 );
                break;
            case 5: // 41.4 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel(sx127x.freq + 41.67e3 );
                break;
            case 6: // 62.5 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            case 7: // 125 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            case 8: // 250 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            }
        }
        else            // 500khz
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) | 0x80 );
        }

        if ( sx127x.lora.freq_hop_on == TRUE )
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, (RFLR_IRQFLAGS_VALIDHEADER |
                                                    RFLR_IRQFLAGS_TXDONE |
                                                    RFLR_IRQFLAGS_CADDONE |
                                                    RFLR_IRQFLAGS_CADDETECTED) );
            // DIO0=RxDone, DIO2=FhssChangeChannel
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK &
                                               RFLR_DIOMAPPING1_DIO2_MASK  ) |
                             RFLR_DIOMAPPING1_DIO0_00 | RFLR_DIOMAPPING1_DIO2_00);
        }
        else
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, (RFLR_IRQFLAGS_VALIDHEADER |
                                                    RFLR_IRQFLAGS_TXDONE |
                                                    RFLR_IRQFLAGS_CADDONE |
                                                    RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                    RFLR_IRQFLAGS_CADDETECTED) );
            // DIO0=RxDone
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK )
                             | RFLR_DIOMAPPING1_DIO0_00 );
        }
        sx127x_write_reg( REG_LR_FIFORXBASEADDR, 0 );
        sx127x_write_reg( REG_LR_FIFOADDRPTR, 0 );

        sx127x.state = RF_RX_STATE;
        if ( sx127x.lora.rx_continuous == TRUE )
        {
            sx127x_set_op_mode( RFLR_OPMODE_RECEIVER );
        }
        else
        {
            sx127x_set_op_mode( RFLR_OPMODE_RECEIVER_SINGLE );
        }

    }
    break;

    default:
        DBG_ASSERT(FALSE __DBG_LINE);
        break;
    }
}


static void sx127x_init(void)
{
    sx127x_reset();

    sx127x_spi_init();
    rx_chain_calibration();

    sx127x_port_init();

    sx127x_set_op_mode(RF_OPMODE_SLEEP);

    sx127x.state = RF_SLEEP_STATE;

    //*< DIO irq
    //@TODO

    for (uint8_t i = 0; i < sizeof(radio_regs_init) / sizeof(radio_regs_t); i++)
    {
        sx127x_set_modem(radio_regs_init[i].modem);
        sx127x_write_reg(radio_regs_init[i].addr, radio_regs_init[i].value);
    }

    sx127x.modem = MODEM_FSK;
    sx127x.lora.rx_continuous = FALSE;

    sx127x_set_modem( MODEM_LORA );
    sx127x_set_power(17);
    sx127x_set_config(7, 8, 1, 1);
    sx127x_set_preamble(8);
    sx127x_set_fix(0);
    sx127x_set_hopping(0, 0);
    sx127x_set_iqinverted(FALSE);
}

rf_result_t sx127x_set_value(rf_cmd_t cmd, uint8_t value)
{
    switch (cmd)
    {
    case RF_MODE:
        sx127x_set_modem(value);
        break;

    case RF_POWER:
        sx127x_set_power(value);
        break;

    default:
        break;
    }
}

void sx1276_prepare(uint8_t *buffer, uint8_t size)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //@todo
        break;

    case MODEM_LORA:
        sx127x_set_iqinverted(sx127x.lora.iq_inverted);

        sx127x.lora_packet.size = size;
        sx127x_write_reg( REG_LR_PAYLOADLENGTH, size );

        // Full buffer used for Tx
        sx127x_write_reg( REG_LR_FIFOTXBASEADDR, 0 );
        sx127x_write_reg( REG_LR_FIFOADDRPTR, 0 );

        // FIFO operations can not take place in Sleep mode
        if ( ( sx127x_read_reg( REG_OPMODE ) & ~RF_OPMODE_MASK ) == RF_OPMODE_SLEEP )
        {
            sx127x_enter_idle();
            delay_ms(1);
        }
        // Write payload buffer
        sx127x_write_buffer( buffer, size );
        break;

    default:
        break;
    }
}


void sx127x_dio0_irq(uint16_t time)
{
    volatile uint8_t irq_flags = 0;
    switch (sx127x.state)
    {
    case RF_RX_STATE:
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //@todo add code
            break;

        case MODEM_LORA:
        {
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE );
            if (sx127x.lora.crc_on)
            {
                irq_flags = sx127x_read_reg( REG_LR_IRQFLAGS );
                if ( ( irq_flags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK ) == RFLR_IRQFLAGS_PAYLOADCRCERROR )
                {
                    // Clear Irq
                    sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR );

                    if ( sx127x.lora.rx_continuous == FALSE )
                    {
                        sx127x.state = RF_IDLE_STATE;
                    }
                    //@todo add code stop rxtimeout timer

                    //@TODO add crc call back

                    return;
                }
            }



            //*< @note read fifo operate
            // sx127x.lora_packet.size = sx127x_read_reg( REG_LR_RXNBBYTES );
            // sx127x_read_buffer( 0, RxBuffer, sx127x.lora_packet.size  );

            if ( sx127x.lora.rx_continuous == false )
            {
                sx127x.state = RF_RXOK_STATE;
            }
            TimerStop( &RxTimeoutTimer );

            if (rf_int_reg[RX_OK_INT] != NULL)
            {
                ( *(rf_int_reg[RX_OK_INT]) )(time);
            }
        }
        break;

        default:
            break;
        }
        break;

    case RF_TX_STATE:
        //@todo cannel txtimeout timer

        //@note clear txok
        if (sx127x.modem == MODEM_LORA)
        {
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE );
        }

        //@todo: TX OK CALL back
        break;

    default:
        break;
    }
}




